<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="generator" content="pandoc" />
    <title>Mod Powers Editorial</title>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    </style>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">

    <style type="text/css">
        body {
            background-color: #e0e0e0;
        }
        .editorial {
            font-family: Georgia,Cambria,"Times New Roman",Times,serif;
            font-size: 20px;
            max-width: 960px;
        }
        .editorial p {
            text-align: justify;
        }
        .editorial .illus {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        .editorial pre {
            background-color: #f8f8f8;
            border: 1px solid #c8c8c8;
            border-radius: 5px;
            padding: 6px;
            /* margin-top: 2px; */
            margin-bottom: 12px;
        }
        .editorial .editorial-section {
            border: 1px solid #c8c8c8;
            border-radius: 10px;
            padding: 1.5rem 1rem 1rem 1rem;
            background-color: white;
        }
        .editorial .theorem {
            border: 1px solid #c8c8c8;
            border-radius: 10px;
            padding: 1rem 1.5rem 0 1.5rem;
            background-color: #f0fff0;
        }
        .editorial .proof {
            border: 1px solid #c8c8c8;
            border-radius: 10px;
            padding: 1rem;
            background-color: #fbfbfb;
        }
        .center-p > p {
            text-align: center;
        }
    </style>

    </head>
<body>

<!--

<div id="header">
<h1 class="title">Mod Powers Editorial</h1>

-->

</div>

<div class="editorial container">
<h1 id="mod-powers">Mod Powers</h1>
<p><strong>Setters:</strong> Cisco Ortega<br />
<strong>Testers:</strong> Kevin Atienza<br />
<strong>Statement Authors:</strong> Cisco Ortega<br />
<strong>Test Data Authors:</strong> Kevin Atienza, Cisco Ortega<br />
<strong>Editorialist:</strong> Cisco Ortega</p>
<p><details class="editorial-section"><summary class="h2">Subtask 1</summary></p>
<p>Alice’s password must look like some alternating series of consonants and vowels. Recall that there are <span class="math inline">\(21\)</span> consonants and <span class="math inline">\(5\)</span> vowels.</p>
<p>There are two cases to consider. In everything that follows, let <code>a</code> represent “any vowel” and let <code>b</code> represent “any consonant”.</p>
<p>If <span class="math inline">\(n\)</span> is even, then there are two possible “shapes”:</p>
<pre><code>ababab
bababa</code></pre>
<p>which we see depends on if our first letter is a consonant or vowel. In either case, the solution is the same: we need to independently choose values for each of the <span class="math inline">\(n/2\)</span> consonants and <span class="math inline">\(n/2\)</span> vowels. Thus, the formula for even <span class="math inline">\(n\)</span> is: <span class="math display">\[5^{n/2} \times 21^{n/2} + 21^{n/2} \times 5^{n/2},\]</span> or <span class="math display">\[2 \times (21 \times 5)^{n/2}\]</span></p>
<p>If <span class="math inline">\(n\)</span> is odd, then there are still two possible “shapes”:</p>
<pre><code>abababa
bababab</code></pre>
<p>which again depends on if our first letter is a consonant or vowel.</p>
<ul>
<li><p>If the first letter is a consonant, then choose which of the <span class="math inline">\(21\)</span> consonants it should be.</p></li>
<li><p>If the first letter is a vowel, then choose which of the <span class="math inline">\(5\)</span> vowels it should be.</p></li>
</ul>
<p>Now we just need to decide the remaining <span class="math inline">\(n-1\)</span> letters. In either case, we end up with <span class="math inline">\((n-1)/2\)</span> consonants and <span class="math inline">\((n-1)/2\)</span> vowels whose values we must independently decide. Thus, the formula for odd <span class="math inline">\(n\)</span> is: <span class="math display">\[21 \times 5^{(n-1)/2} \times 21^{(n-1)/2} + 5 \times 21^{(n-1)/2} \times 5^{(n-1)/2},\]</span> or <span class="math display">\[(21 + 5) \times (21 \times 5)^{(n-1)/2}.\]</span></p>
<p>It may be a bit tedious, but you can still manually compute the value by hand when <span class="math inline">\(n=10\)</span>, using this formula. Just use a calculator to speed things up.</p>
<p></details></p>
<p><details class="editorial-section"><summary class="h2">Subtask 2</summary></p>
<p>Directly implement this formula in code, where we implement exponentiation as repeated multiplication—compute <span class="math inline">\(a^b\)</span> by multiplying <span class="math inline">\(a\)</span> to itself <span class="math inline">\(b\)</span> times. Note that because of combinatorial explosion, the raw answer is going to be huge—so you must take modulos at each intermediary step.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># pseudocode</span>

n <span class="op">=</span> <span class="dv">13</span><span class="op">**</span><span class="dv">7</span>
MOD <span class="op">=</span> <span class="dv">10</span><span class="op">**</span><span class="dv">9</span> <span class="op">+</span> <span class="dv">7</span>

<span class="co"># n is odd here</span>
ans <span class="op">=</span> <span class="dv">21</span><span class="op">+</span><span class="dv">5</span>
<span class="cf">for</span> (n<span class="dv">-1</span>)<span class="op">/</span><span class="dv">2</span> times:
    ans <span class="op">*=</span> <span class="dv">21</span><span class="op">*</span><span class="dv">5</span>
    ans <span class="op">%=</span> MOD
<span class="bu">print</span>(ans)</code></pre></div>
<p>Even a slow language like Python can do on the order of <span class="math inline">\(\approx 10^7\)</span> operations per second, so this should terminate within a few seconds for the <span class="math inline">\(n\)</span> in subtask <span class="math inline">\(2\)</span>.</p>
<p></details></p>
<p><details class="editorial-section"><summary class="h2">Subtask 3</summary></p>
<p>If <span class="math inline">\(n\)</span> is very very large, then “literally do something <span class="math inline">\(n/2\)</span> times” is way too slow. We need a faster exponentiation algorithm so that we can use our magic formula.</p>
<p>If you Google “fast exponentiation algorithm”, you’ll find many results for algorithms that achieve the result in only <span class="math inline">\(\sim \log_2 n\)</span> multiplications. Such algorithms usually (explicitly or implicitly) leverage the binary representation of the exponent. The Wikipedia article calls the technique, “exponentiation by squaring”.</p>
<p>The author would also like to suggest his writeup <a href="https://drive.google.com/file/d/1zTTVo1W8XwpYdEEeW-iete2aJX7IzoZc/view?usp=drive_link">here</a> which gives a recursive formulation of the algorithm.</p>
<p>Pick your favorite algorithm and implement it, and you will solve subtask <span class="math inline">\(3\)</span> in a fraction of a second.</p>
<p></details></p>
<p><details class="editorial-section"><summary class="h2">Subtask 4</summary></p>
<h3 id="dealing-with-power-towers" class="unnumbered">Dealing with power towers</h3>
<p>Let’s suppose that we already have an algorithm that allows us to compute <span class="math inline">\(a^b \bmod m\)</span> in <span class="math inline">\(\sim \log_2 b\)</span> steps. Unfortunately, the “power tower” in subtask <span class="math inline">\(4\)</span> is absolutely massive, and even <span class="math inline">\(\log_2 \left(7^{7^{7^{2023}}}\right)\)</span> is astronomically large.</p>
<p>We need a way of trimming the size <em>of the exponent</em>.</p>
<p>One classic approach is to use <strong>Euler’s Theorem</strong>. Let <span class="math inline">\(a\)</span> and <span class="math inline">\(m\)</span> be coprime integers. Then, <span class="math display">\[a^{\varphi(m)} \equiv 1 \pmod m\]</span> where <span class="math inline">\(\varphi\)</span> is Euler’s Totient function, and <span class="math inline">\(\varphi(m)\)</span> counts the number of positive integers less than or equal to <span class="math inline">\(m\)</span> which are coprime to it. There are many proofs of Euler’s Theorem online which you can refer to.</p>
<p>Let <span class="math inline">\(b \geq \phi(m)\)</span>. Euler’s Theorem tells us that: <span class="math display">\[a^{b + \varphi(m)} \equiv a^b \equiv a^{b - \varphi(m)} \pmod m,\]</span> which inductively means that, <span class="math display">\[a^b \equiv a^{b + k\varphi(m)} \pmod m,\]</span> for any non-negative integer <span class="math inline">\(k\)</span> such that <span class="math inline">\(b + k \phi(m) \geq 0\)</span>.</p>
<p>But since <span class="math inline">\(b \bmod \varphi(m) = b - \lfloor b/\varphi(m) \rfloor \varphi(m)\)</span>, we conclude that: <span class="math display">\[a^b \equiv a^{b \bmod \varphi(m)} \pmod m.\]</span></p>
<p>Returning to power towers, that means, for example: <span class="math display">\[a^{b^{c^{d^e}}} \equiv a^{b^{c^{d^e}} \bmod \varphi(m)} \pmod m.\]</span> In other words, we know that we can compute <span class="math inline">\(a^{b^{c^{d^e}}} \bmod m\)</span> efficiently if we know how to compute <span class="math inline">\(b^{c^{d^e}} \bmod \varphi(m)\)</span> efficiently. But that’s just a slightly smaller power tower problem! So, recursively, we can just use the same trick again!<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> For example here, you can evaluate <span class="math inline">\(b^{c^{d^e}} \bmod \varphi(m)\)</span> by evaluating <span class="math inline">\(c^{d^e} \bmod \varphi(\varphi(m))\)</span>, and so on.</p>
<p>Repeatedly apply this Euler’s Theorem trick to shave levels off your power tower until you hit a case where the exponent is small enough that a fast exponentiation algorithm can do the trick.</p>
<h3 id="dividing-by-2" class="unnumbered">Dividing by <span class="math inline">\(2\)</span></h3>
<p>Going back to our problem, recall that we want to compute (since <span class="math inline">\(n=7^{7^{7^{2023}}}\)</span> is odd): <span class="math display">\[26 \times 105^{\left(n - 1\right)/2} \pmod p,\]</span> where <span class="math inline">\(p = 10^9 + 7\)</span>. From the power-tower trick we just discussed, we know that this task can be done if we can compute, <span class="math display">\[(7^{7^{7^{2023}}}-1)/2 \pmod {\varphi(p)},\]</span> which (as we said) is done by repeating the Euler’s Theorem trick. There’s one final hiccup we need to address—<span class="math inline">\(\varphi(10^9 + 7)\)</span> is <strong>even</strong>, meaning that <span class="math inline">\(2\)</span> does not have a unique multiplicative inverse modulo <span class="math inline">\(\varphi(p)\)</span>. How do we divide by <span class="math inline">\(2\)</span> now?</p>
<p>We need one more trick. Suppose <span class="math inline">\(a\)</span> is divisible by some <span class="math inline">\(d\)</span>, and <span class="math display">\[a \equiv r \pmod{dm}\]</span> Then, we can show that <span class="math inline">\(r\)</span> is also divisible by <span class="math inline">\(d\)</span>, and that <span class="math display">\[\frac{a}{d} \equiv \frac{r}{d} \pmod m.\]</span></p>
<p>All this means for us is that we need to compute: <span class="math display">\[7^{7^{7^{2023}}}-1 \pmod{2~\varphi(p)},\]</span> which we do using already-established power tower techniques. <em>This result</em> can be divided by <span class="math inline">\(2\)</span> to get what we wanted.</p>
<p>Apply the division algorithm where we divide <span class="math inline">\(a\)</span> by <span class="math inline">\(dm\)</span>. There is a unique pair of integers <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> such that <span class="math inline">\(0 \leq r &lt; dm\)</span> and <span class="math display">\[a = (dm)q + r.\]</span> Note that <span class="math inline">\(dmq\)</span> is divisible by <span class="math inline">\(d\)</span>; so if <span class="math inline">\(a\)</span> is divisible by <span class="math inline">\(d\)</span>, then the sum on the RHS must also be divisible by <span class="math inline">\(d\)</span>, and so <span class="math inline">\(r\)</span> must be divisible by <span class="math inline">\(d\)</span> as well.</p>
<p>Dividing both sides by <span class="math inline">\(d\)</span>: <span class="math display">\[\frac{a}{d} = mq + \frac{r}{d}.\]</span> and here, <span class="math inline">\(0 \leq \dfrac{r}{d} &lt; m\)</span>.</p>
<p>Now, apply the division algorithm where we divide <span class="math inline">\(\dfrac{a}{d}\)</span> by <span class="math inline">\(m\)</span>. There is a <strong>unique</strong> pair of integers <span class="math inline">\(q&#39;\)</span> and <span class="math inline">\(r&#39;\)</span> such that <span class="math inline">\(0 \leq r&#39; &lt; m\)</span> and <span class="math display">\[\frac{a}{d} = mq&#39; + r&#39;.\]</span> But note that <span class="math inline">\(\left(q, \dfrac{r}{d}\right)\)</span> satisfies these criteria for <span class="math inline">\((q&#39;, r&#39;)\)</span>; by the uniqueness of <span class="math inline">\((q&#39;, r&#39;)\)</span>, we therefore conclude that <span class="math inline">\(r&#39; = \dfrac{r}{d}\)</span>, which is what we wanted to show.</p>
<h3 id="computing-totients" class="unnumbered">Computing totients</h3>
<p>One standard way of computing the totient function of large integers is to use the fact that the totient function is <em>multiplicative</em>. You can do the following steps to evaluate <span class="math inline">\(\varphi(m)\)</span>:</p>
<ul>
<li><p>First, prime factorize <span class="math inline">\(m = p_1^{e_1} p_2^{e_2} \dots p_l^{e_k}\)</span>. There are simple factorization algorithms that run in <span class="math inline">\(\sim \sqrt{m}\)</span> steps, and that’s fast enough for our purposes.</p></li>
<li><p>Now, <span class="math inline">\(\varphi\)</span> is multiplicative, meaning <span class="math display">\[\varphi\left(p_1^{e_1} p_2^{e_2} \dots p_l^{e_k}\right) = \varphi\left(p_1^{e_1}\right)\varphi\left(p_2^{e_2}\right) \dots \varphi\left(p_k^{e_k}\right)\]</span></p></li>
<li><p>Finally, the totient function is easy to compute for prime powers. By straightforward combinatorics, you can show that <span class="math inline">\(\varphi(p^e) = p^e - p^{e-1}\)</span>, when <span class="math inline">\(p\)</span> is a prime and <span class="math inline">\(e\)</span> is an integer <span class="math inline">\(\geq 1\)</span>. So, use this formula for each prime power, then multiply the results.</p></li>
</ul>
<p>There are many explanations online for why <span class="math inline">\(\varphi\)</span> is multiplicative (or what it means for a function to be multiplicative, in general).</p>
<p>An alternatively <em>incredibly low-effort</em> solution is to realize that for this problem, we only need to evaluate <span class="math inline">\(\varphi(p)\)</span>, <span class="math inline">\(\varphi(2\varphi(p))\)</span>, and <span class="math inline">\(\varphi(\varphi(2\varphi(p)))\)</span>. Since you only need to evaluate the totient function at a handful of points, you could also just ask WolframAlpha to perform these computations for you.</p>
<p></details></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>You have to be a bit careful when considering the cases where your base is not coprime to your modulus<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

</body>
</html>
